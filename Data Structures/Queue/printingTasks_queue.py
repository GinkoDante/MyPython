import random
import time

class Queue:
    def __init__(self):
        self.items = []

    def enqueue(self, item):
        self.items.insert(0,item)

    def dequeue(self):
        return self.items.pop()

    def isEmpty(self):
        return self.items == []

    def size(self):
        return len(self.items)

# Takes a task and computes how long it takes
# to run and whether it is currently busy with a task
class Printer:

    # Define setting as slow (5 sheets/min) or fast (10 sheets/min)
    def __init__(self, pagesperMin):
        self.currentTask = None
        self.pageRate = pagesperMin
        self.timeRemaining = 0

    # Indicate if it is currently busy with a task
    def busy(self):
        if self.currentTask == None:
            return False
        else:
            return True

    # Start a new task
    def startNextTask(self, newTask):

        if self.currentTask == None:

            self.currentTask = newTask

            # Set time Remaining in seconds: Num Pages * 60 seconds /  NumPages per 1 minute:
            # Num Pages = 10, pageRate = 5 pages per MINUTE
            # timeRemaining = 10 * 60 / 5 = 600 / 5 = 120 seconds to print 10 pages at 5 pages per Minute
            self.timeRemaining = newTask.getNumPages() * 60 / self.pageRate

    # Decrement internal timer updating timeRemaining
    def tick(self):

        # If we currently have a task which is running
        if self.currentTask != None:
            self.timeRemaining -= 1

        # If we reach the end of the timeRemaining for task
        # then task has completed
        if self.timeRemaining <= 0:
            self.currentTask = None


# Represents a single printing task
# Will specify number of pages to print [1-20]
class Task:

    def __init__(self, time, maxNumPages):
        self.numPages = random.randrange(1, maxNumPages+1)
        self.createTime = time

    # Defines how long Task was in queue before getting run by Printer
    def waitTime(self, currentTime):
        return currentTime - self.createTime

    def getTimeStamp(self):
        return self.createTime

    def getNumPages(self):
        return self.numPages

'''
class Student:

    def __init__(self, maxNumTasks, maxNumPages, numStudents, maxTasksPerStudent):
        # If this number is randomly generated by newTask then this Student has submitted
        # a new Task to occur
        self.taskNum = random.randrange(1, 3600 / (numStudents * maxTasksPerStudent))
'''


''' Input:
        numSeconds: Number of seconds to run simulation
        pagesPerMinute: setting for how fast the printer should print during this simulation
    Action:
        Run a simulation to create and run tasks on a printer
        Tasks are held in a queue until the printer is not busy
        Waiting Times for a task are held in a list

    Result: Runs tasks for a specified number of "Seconds" (really just iterations)
            Checks how much time it takes to complete tasks and records how long the
            task was in a queue for
'''
def Simulation(numSeconds, pagesPerMinute, numStudents, maxTasksPerStudent, maxNumPages):

    printQueue = Queue()
    labPrinter = Printer(pagesPerMinute)

    # Will hold amount of time task was in queue before getting to run on the printer
    waitingTimes = []

    for currentSecond in range(numSeconds):

        # Test if new print task was created
        if newPrintTask(numStudents, maxTasksPerStudent):
            # if so create the task and set the time it was added to the queue
            task = Task(currentSecond, maxNumPages)
            # add the task to the printer queue
            printQueue.enqueue(task)

        #Test if printer can run a new Task from printer Queue
        if (not labPrinter.busy()) and (not printQueue.isEmpty()):

            # Remove top Task from queue and run on Printer
            newTask = printQueue.dequeue()

            # Get the amount of time task has been waiting on Queue before getting to printer
            waitingTimes.append(newTask.waitTime(currentSecond))

            # Let printer run the task
            labPrinter.startNextTask(newTask)

        # Decrement the time task has been running on Printer
        labPrinter.tick()

    averageWaitTime = sum(waitingTimes) / len(waitingTimes)

    print("Average Wait %6.2f secs\n After %d seconds %3d tasks remaining to print."%(averageWaitTime,numSeconds, printQueue.size()))


# Generate random new Tasks to be sent to the Printing Queue
def newPrintTask(numStudents, maxTasksPerStudent):

    maxNumTasks = numStudents * maxTasksPerStudent

    # num Task possible = max number of tasks / 1 hour * 1 hour/60 min * 1 min/60 sec = 1 task/ num seconds
    maxNumTasksPerSim = 3600 / maxNumTasks

    # Generate a random number from 1 to maxnumber of Tasks
    num = random.randrange(1, maxNumTasks+1)

    # If this number is 180 then generate a new Print Task
    # 180 number is dependent upon the number of students in the lab
    if num == maxNumTasks:
        return True

    else:
        return False


# Run simulation 10 times with each run having 3600 iterations to run
# printing x number of pages per minute and with 20 students in the printing lab
for i in range(10):
    print("Simulation %d:\n"%i)
    '''
        Input:
            a. numSeconds: # of iterations o run simulation for
            b. Pages Per minute: # of pages printer can generate a minute
            c. numStudents: The number of students affects how many tasks can be generated
            d. maxNumTasksPerStudent: how many tasks a student can run during the simulation
            e. maxNumberofPages: max # of pages a student could print in one task
    '''
    Simulation(3600, 10, 40, 3, 25)
    print("\n")